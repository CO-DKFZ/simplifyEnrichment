---
title: "Simplify Gene Ontology Enrichment Results"
author: "Zuguang Gu (z.gu@dkfz.de)"
date: '`r Sys.Date()`'
output: 
  html_document:
    fig_caption: true
vignette: >
  %\VignetteIndexEntry{Simplify Gene Ontology Enrichment Results}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

----------------------------------------

```{r, echo = FALSE}
library(knitr)
knitr::opts_chunk$set(
    error = FALSE,
    tidy  = FALSE,
    message = FALSE,
    warning = FALSE,
    fig.align = "center")
```

## Introduction

Gene Ontology enrichment analysis is very frequently used in bioinformatics
field. In many cases, the results contain a long list of significantly
enriched GO terms which has highly redundant information and is difficult to
summarize. The GO enrichment results can be reduced by clustering GO terms
into groups where in the same group the GO terms are similar. The similarity
between GO terms is called **the semantic similarity** and can be calculated
by many software such as [the **GOSemSim**
package](https://bioconductor.org/packages/release/bioc/html/GOSemSim.html).
Figure 1 is an example of the semantic similarity matrix from 500
randomly generated GO terms.

```{r, fig.width = 4, fig.height = 4, echo = FALSE, fig.cap = "Figure 1. A heatmap of the semantic similarity matrix from 500 random GO terms."}
library(simplifyEnrichment)
library(circlize)
library(ComplexHeatmap)
set.seed(888)
go_id = random_GO(500)
mat = GO_similarity(go_id)
col_fun = colorRamp2(c(0, 1), c("white", "red"))
Heatmap(mat, name = "Similarity", col = col_fun,
	show_row_names = FALSE, show_column_names = FALSE,
	show_row_dend = FALSE, show_column_dend = FALSE,
	border = "#404040", column_title = "GO similarity matrix")
```

The GO similarity heatmap has a very special pattern that there are blocks
located on the diagonal where GO terms in the same block have similar functions. 
This is due to the structure of Directed Acyclic Graph (DAG) of GO. 

Classifying GO terms into groups basically is to apply clustering on the GO
simialrity matrix. To solve this problem, there are two type of methods. 1.
applying clustering methods that directly apply to a matrix. 2. treat the
similarity matrix as adjacency matrix and convert the matrix to a weighted
network. Then apply network module/community methods.

There are two major problems for the clustering of GO terms: 1. the size of the 
clusters varies a lot, which means, there are very large clusters, while at the
same time, there are also tiny clusters. An effective clustering should be able
not to be affected by the cluster size. 2. For the big clusters, the density of 
the similarity are not as dense as the small ones, thus big clusters should not
be split into further small clusters and produce redendency.

Here we proposed a new clustering method called "binary cut" to spit GO terms into groups.
The idea behind is very intuitive to identify "blocks" in the similarity heatmap.
As shown in Figure 2, the two heatmaps are both similarity matrices for two subsets
of GO terms. 


```{r, fig.width = 6, fig.height = 3, echo = FALSE, out.width = "50%", fig.cap = "Figure 2. Two similarity matrices."}
cl = binary_cut(mat)
tb = sort(table(cl), decreasing = TRUE)
ind1 = which(as.character(cl) %in% names(tb)[1])
ind2 = which(as.character(cl) %in% names(tb)[1:2])

mat1 = mat[ind1, ind1]
km = kmeans(mat1, centers = 2)$cluster
plot1 = grid.grabExpr({
	draw(Heatmap(mat1, name = "mat1", col = col_fun, show_row_dend = FALSE, show_column_dend = FALSE, 
		row_split = km, column_split = km,
		show_row_names = FALSE, show_column_names = FALSE,
		border = "#404040", row_title = NULL, column_title = "Similarity sub-matrix 1",
		row_gap = unit(0, "mm"), column_gap = unit(0, "mm"), show_heatmap_legend = FALSE))
	decorate_heatmap_body("mat1", { ComplexHeatmap:::grid.text(gt_render("*s*<sub>11</sub>"), x = 0.5, y = 0.5, gp = gpar(fontfamily = "Times", fontsize = 20)) }, row_slice = 1, column_slice = 1)
	decorate_heatmap_body("mat1", { ComplexHeatmap:::grid.text(gt_render("*s*<sub>12</sub>"), x = 0.5, y = 0.5, gp = gpar(fontfamily = "Times", fontsize = 20)) }, row_slice = 1, column_slice = 2)
	decorate_heatmap_body("mat1", { ComplexHeatmap:::grid.text(gt_render("*s*<sub>21</sub>"), x = 0.5, y = 0.5, gp = gpar(fontfamily = "Times", fontsize = 20)) }, row_slice = 2, column_slice = 1)
	decorate_heatmap_body("mat1", { ComplexHeatmap:::grid.text(gt_render("*s*<sub>22</sub>"), x = 0.5, y = 0.5, gp = gpar(fontfamily = "Times", fontsize = 20)) }, row_slice = 2, column_slice = 2)
})
mat2 = mat[ind2, ind2]
km = kmeans(mat2, centers = 2)$cluster
plot2 = grid.grabExpr({
	draw(Heatmap(mat2, name = "mat1", col = col_fun, show_row_dend = FALSE, show_column_dend = FALSE, 
		row_split = km, column_split = km,
		show_row_names = FALSE, show_column_names = FALSE,
		border = "#404040", row_title = NULL, column_title = "Similarity sub-matrix 2",
		row_gap = unit(0, "mm"), column_gap = unit(0, "mm"), show_heatmap_legend = FALSE))
	decorate_heatmap_body("mat1", { ComplexHeatmap:::grid.text(gt_render("*s*<sub>11</sub>"), x = 0.5, y = 0.5, gp = gpar(fontfamily = "Times", fontsize = 20)) }, row_slice = 1, column_slice = 1)
	decorate_heatmap_body("mat1", { ComplexHeatmap:::grid.text(gt_render("*s*<sub>12</sub>"), x = 0.5, y = 0.5, gp = gpar(fontfamily = "Times", fontsize = 20)) }, row_slice = 1, column_slice = 2)
	decorate_heatmap_body("mat1", { ComplexHeatmap:::grid.text(gt_render("*s*<sub>21</sub>"), x = 0.5, y = 0.5, gp = gpar(fontfamily = "Times", fontsize = 20)) }, row_slice = 2, column_slice = 1)
	decorate_heatmap_body("mat1", { ComplexHeatmap:::grid.text(gt_render("*s*<sub>22</sub>"), x = 0.5, y = 0.5, gp = gpar(fontfamily = "Times", fontsize = 20)) }, row_slice = 2, column_slice = 2)
})

grid.newpage()
pushViewport(viewport(x = 0, width = 0.5, just = "left"))
grid.draw(plot1)
popViewport()
pushViewport(viewport(x = 0.5, width = 0.5, just = "left"))
grid.draw(plot2)
popViewport()
```

Let denote them as $M_a$ (the left matrix) and $M_b$ (the right matrix).
Intuitively, terms in $M_a$ all have high pairwise similarity and thus should not be
further split, while terms in $M_b$ still show two-group patterns and should be further
split into two groups. To measure whether a certain subset of GO terms need to be split, 
we calculate a score $s$ as follows:

For a similarity sub-matrix which corresponds to a subset of GO terms, e.g. $M_a$ or $M_b$,
apply k-kmeans clustering with two groups on rows and partition the matrix into four parts,
as shown in Figure 2. Denote the values for the four partitions as $s_{11}$, $s_{12}$, $s_{21}$ and $s_{22}$,
where e.g. $s_{11}$ is the median value of the sub-matrix it corresponds to. The score $s$ is calcualted as:

$$s = \frac{s_{11} + s_{22}}{s_{11} + s_{12} + s_{21} + s_{22}}$$

Naturally, if $s$ is close to 0.5 (e.g. the left heatmap), all the terms are highly similar
and they should not be split any more, while if $s$ is close to 1, it means the group of GO terms
can still be split into two groups.

The algorithm is composed of two phases:

phase 1: clustering

1. for a similarity matrix, apply k-kmeans with two groups, calcualte $s$
2. for the two submatrix, apply step 1 recursively


phase 2: cut the dendrogram:

If the process are formatted as a dendrogram, the splitting can

1. split if the score of the node is larger than the cutoff
2. because the node more on the top have ... smaller scores, thus, if the node does
   not exceed the cutoff, but at least one of its child nodes exceed the cutoff,
   the node is still split.

An example of splitting previous heatmap by binary cut is:

```{r, fig.width = 20, fig.height = 4, echo = FALSE, fig.cap = "Figure 3. Process of binary clustering the similarity matrix. In the plot only the first 4 iterations are shown."}
dend = simplifyEnrichment:::cluster_mat(mat)
p1 = grid.grabExpr(simplifyEnrichment:::plot_binary_cut(mat, dend = dend, depth = 1, show_heatmap_legend = FALSE))
p2 = grid.grabExpr(simplifyEnrichment:::plot_binary_cut(mat, dend = dend, depth = 2, show_heatmap_legend = FALSE))
p3 = grid.grabExpr(simplifyEnrichment:::plot_binary_cut(mat, dend = dend, depth = 3, show_heatmap_legend = FALSE))
p4 = grid.grabExpr(simplifyEnrichment:::plot_binary_cut(mat, dend = dend, depth = 4, show_heatmap_legend = FALSE))
library(cowplot)
plot_grid(p1, p2, p3, p4, nrow = 1)
```

And the splitting the dendrogram. The cross are on the nodes that need to be split.

```{r, fig.width = 6, fig.height = 4, echo = FALSE, fig.cap = "Figure 4. Splitting the dendrogram."}
simplifyEnrichment:::plot_binary_cut(mat)
```

As we can see there are a lot of tiny clusters. They can be put into a separated group.
In the following plot, clusters with size less than 5 are put into a separated group marked
by a green line, which makes the plot looks more clean.

```{r, fig.width = 5, fig.height = 4, echo = FALSE, fig.cap = "Figure 5. Visualize the ..."}
cl = simplifyEnrichment:::cut_dend(dend)
ht_clusters(mat, cl, draw_word_cloud = FALSE)
```

Once the GO terms are clustered into groups, the ... can be summarized by word cloud and appended to the heatmap.

```{r, fig.width = 8, fig.height = 4, echo = FALSE, fig.cap = "Figure 6. ..."}
df = simplifyGO(mat, verbose = FALSE)
```

## Usage

**simplifyGO** starts with the GO similarity matrix. Users can use their own
similarity matrices or use the `GO_similarity()` function to calculate one. The
`GO_similarity()` function is simply a wrapper on `GOSemSim::mgoSim`. The
function accepts a vector of GO IDs. Note the GO should only belong to one
same ontology (i.e. `BP`, `CC` or `MF`).

In the following example, we sample 500 random GO IDs from GO biological process
(BP) ontology.

```{r}
set.seed(888)
go_id = random_GO(500)
mat = GO_similarity(go_id)
```

By default, `GO_similarity()` uses `Rel` method. Other method to calculate GO
similarities can be set by `measure` argument, e.g:

```{r, eval = FALSE}
GO_similarity(go_id, measure = "Wang")
```

With the similarity matrix `mat`, users can directly apply `simplifyGO()`
function to perform the clustering and visualize the results. The plot is the
same as the previous one, thus here we won't generate it again in the vignette.

```{r, fig.width = 8, fig.height = 5, eval = FALSE}
df = simplifyGO(mat)
```

In `simplifyGO()`, besides the default clustering method `binary_cut`, users
can also use other clustering methods. The supported methods are:

- `binary_cut`: This is the default clustering method and it runs `binary_cut()`.
- `kmeans`: It uses k-means clustering. The number of clusters are tried with
  `2:min(round(nrow(mat)/5), 100)`. The best number of k for k-means
  clustering is identified according to the "elbow" or "knee" method on the
  distribution of within-cluster sum of squares at each k.
- `dynamicTreeCut` It uses `dynamicTreeCut::cutreeDynamic()`.
- `mclust`: It uses `mclust::Mclust()`. The value of `G` in `mclust::Mclust()`
  is set to `1:min(round(nrow(mat)/5), 100)`.
- `apcluster`: It uses `apcluster::apcluster()`.
- `fast_greedy`: It treats the similarity matrix as an ajacency matrix and
  converts it to a graph/network where the similarity values are the weight of
  the edges of the graph, then the clustering on the similarity matrix is converted
  to looking for communities in the graph. This method applies `igraph::cluster_fast_greedy()` to detect
  communities in the graph.
- `leading_eigen`: It is a graph community detection method. It uses
  `igraph::cluster_leading_eigen()`.
- `louvain`: It is a graph community detection method. It uses
  `igraph::cluster_louvain()`.
- `walktrap`: It is a graph community detection method. It uses
  `igraph::cluster_walktrap()`.

**Please note, all other methods are mainly for comparing to our `binary_cut` method.
They are not recommended to use.**

On the right side of the heatmap are the word cloud annotations which summarize
the functions with keywords in every GO cluster. Following parameters control the generation
and graphic parameters of the word clouds:

- `draw_word_cloud`: Whether to draw the word clouds.
- `min_term`: Minimal number of GO terms in a cluster. All the clusters with
  size less than `min_term` are all merged into one single cluster in the
  heatmap.
- `order_by_size`: Whether to reorder GO clusters by their sizes. The cluster
  that is merged from small clusters (size < 5) is always put to the bottom of
  the heatmap.
- `exclude_words`: Words that are excluded in the word cloud. E.g. in previous example, the word
  "regulation" and "process" can be excluded.
- `max_words`: Maximal number of words visualized in the word cloud.
- `word_cloud_grob_param`: This controls the graphic parameters for the word
  clouds. The value should be a list and is passed to `word_cloud_grob()`
  function. There are following graphic parameters:
	* `line_space`: Space between lines. The value can be a `grid::unit`
	  object or a numeric scalar which is measured in mm.
	* `word_space`: Space between words. The value can be a `grid::unit`
	  object or a numeric scalar which is measured in mm.
	* `max_width`: The maximal width of the viewport to put the word cloud.
	  The value can be a `grid::unit` object or a numeric scalar which is
	  measured in mm. Note this might be larger than the final width of the
	  returned grob object.
	* `col`: Colors for the words. The value should be a self-defined function
	  that takes the number of words and font size as the two arguments. The
	  function should return a color vector.
- `fontsize_range`: The range of the font size. The value should be a numeric
  vector with length two. The minimal font size is mapped to word frequency
  value of 1 and the maximal font size is mapped to the maximal word
  frequency. The font size interlopation is linear.

Note there is no word cloud for the cluster that is merged from small clusters (size < 5).

The returned variable `df` is a data frame with GO IDs, GO term names and the
cluster labels:

```{r}
head(df)
```

The size of GO clusters can be retrieved by:

```{r}
sort(table(df$cluster))
```

`plot` argument can be set to `FALSE` in `simplifyGO()`, so that no plot is generated and only
the data frame is returned.

If the aim is only to cluster GO terms, `binary_cut()` function can be directly applied:

```{r}
binary_cut(mat)
```

## Benchmark

We compared following clustering methods:

- binary_cut
- kmeans
- dynamicTreeCut
- mclust
- apcluster 
- fast_greedy
- leading_eigen
- louvain
- walktrap     

### On random datasets

500 random GO terms are generated from Biology Process ontology. One example
of the clustering from different methods are in Figure 7. Basically we can see
`kmeans`, `dynamicTreeCut`, `mclust` and `apcluster` generate too many small clusters
and cannot split tiny cluster. `fast_greedy`, `leading_eigen`, `louvain` and `walktrap`
can identify small and large cluster, however, some large clusters are too ... 

```{r, echo = FALSE, fig.cap = "Figure 7. ..."}
knitr::include_graphics("GO_heatmap_random_BP_1.jpg")
```

The random GO terms were generated 100 times and we compared following metrics:

1. the different between the similarity values for the terms
 that belong to the same clusters and in different clusters. The difference score
 is the Kolmogorov-Smirnov statistic between the two distributions.
2. Number of clusters. For each there are two numbers: the number of all clusters and
  the number of clusters with size >= 5
3. the mean of the blocks

```{r, echo = FALSE, fig.width = 4, fig.cap = "Figure 8. ..."}
lt = readRDS("random_BP_results.rds")
diff_score_df = lt$diff_score_df
cluster_number_df = lt$cluster_number_df
cluster_number2_df = lt$cluster_number2_df
block_mean_df = lt$block_mean_df
arr = lt$arr

library(ggplot2)
library(grid)
p1 = ggplot(diff_score_df, aes(x = method, y = value)) +
	geom_boxplot() + ylab("Difference score") +
	theme(axis.title.x = element_blank(), axis.text.x = element_blank())

cluster_number_df$type = "All sizes"
cluster_number2_df$type = "size >= 5"
p2 = ggplot(rbind(cluster_number_df, cluster_number2_df), aes(x = method, y = value, col = type)) +
	geom_boxplot() + ylab("cluster number") +
	theme(axis.title.x = element_blank(), axis.text.x = element_blank())

p3 = ggplot(block_mean_df, aes(x = method, y = value)) +
	geom_boxplot() + ylab("Block mean") +
	theme(axis.title.x = element_blank(), axis.text.x = element_text(angle = 45, hjust = 1))
library(cowplot)
plot_grid(p1, p2, p3, nrow = 3, align = "v", axis = "lr", rel_heights = c(1, 1, 1.3))
```

In Figure 8, we can see

Next we calculate the similarity between clustering methods. For the partitions
from two methods, first adjust the labels...

Then the concordance of the two partitions is calculated as:


Figure 9 show the mean concordance ...

```{r, echo = FALSE, fig.width = 4, fig.cap = "Figure 9. ..."}
m_mean = apply(arr, 1:2, mean)
Heatmap(m_mean, name = "concordance")
```

The heatmaps for the 100 runs of random GO terms can be found at https://jokergoo.github.io/simplifyGO_figures/random_BP.html.


### On real datasets

We downloaded the datasets from [EBI Expression Atlas](https://www.ebi.ac.uk/gxa/download).
We applied [**clusterProfiler**](https://bioconductor.org/packages/release/bioc/html/clusterProfiler.html) 
to the significantly expressed genes only with the GO Biological Process ontology. And we
only took the datasets with significant GO terms in [100, 1000].


```{r, echo = FALSE, fig.width = 4, fig.cap = "Figure 10. ..."}
lt = readRDS("EBI_Expression_Atlas_results.rds")
diff_score_df = lt$diff_score_df
cluster_number_df = lt$cluster_number_df
cluster_number2_df = lt$cluster_number2_df
block_mean_df = lt$block_mean_df
arr = lt$arr

library(ggplot2)
library(grid)
p1 = ggplot(diff_score_df, aes(x = method, y = value)) +
	geom_boxplot() + ylab("Difference score") +
	theme(axis.title.x = element_blank(), axis.text.x = element_blank())

cluster_number_df$type = "All sizes"
cluster_number2_df$type = "size >= 5"
p2 = ggplot(rbind(cluster_number_df, cluster_number2_df), aes(x = method, y = value, col = type)) +
	geom_boxplot() + ylab("cluster number") +
	theme(axis.title.x = element_blank(), axis.text.x = element_blank())

p3 = ggplot(block_mean_df, aes(x = method, y = value)) +
	geom_boxplot() + ylab("Block mean") +
	theme(axis.title.x = element_blank(), axis.text.x = element_text(angle = 45, hjust = 1))

plot_grid(p1, p2, p3, nrow = 3, align = "v", axis = "lr", rel_heights = c(1, 1, 1.3))
```

```{r, echo = FALSE, fig.width = 4, fig.cap = "Figure 11. ..."}
m_mean = apply(arr, 1:2, mean)
Heatmap(m_mean, name = "concordance")
```

The heatmaps can be found at https://jokergoo.github.io/simplifyGO_figures/EBI_Expression_Atlas.html.


## Session Info

```{r}
sessionInfo()
```
