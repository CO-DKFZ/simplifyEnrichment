<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Simplify Gene Ontology Enrichment Results • simplifyEnrichment</title>
<!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script><!-- Bootstrap --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/css/bootstrap.min.css" integrity="sha256-bZLfwXAP04zRMK2BjiO8iu9pf4FbLqX6zitd+tIvLhE=" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script><!-- bootstrap-toc --><link rel="stylesheet" href="../bootstrap-toc.css">
<script src="../bootstrap-toc.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script><meta property="og:title" content="Simplify Gene Ontology Enrichment Results">
<meta property="og:description" content="simplifyEnrichment">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body data-spy="scroll" data-target="#toc">
    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">simplifyEnrichment</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="Released version">0.99.0</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../index.html">
    <span class="fas fa fas fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/simplifyGO.html">Simplify Gene Ontology Enrichment Results</a>
    </li>
  </ul>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="https://github.com/jokergoo/simplifyEnrichment/">
    <span class="fab fa fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      

      </header><script src="simplifyGO_files/header-attrs-2.1/header-attrs.js"></script><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1 data-toc-skip>Simplify Gene Ontology Enrichment Results</h1>
                        <h4 class="author">Zuguang Gu (<a href="mailto:z.gu@dkfz.de" class="email">z.gu@dkfz.de</a>)</h4>
            
            <h4 class="date">2020-05-01</h4>
      
      <small class="dont-index">Source: <a href="https://github.com/jokergoo/simplifyEnrichment/blob/master/vignettes/simplifyGO.Rmd"><code>vignettes/simplifyGO.Rmd</code></a></small>
      <div class="hidden name"><code>simplifyGO.Rmd</code></div>

    </div>

    
    
<div id="introduction" class="section level2">
<h2 class="hasAnchor">
<a href="#introduction" class="anchor"></a>Introduction</h2>
<p>Gene Ontology enrichment analysis is very frequently used in the bioinformatics field. In many cases, the results contain a long list of significantly enriched GO terms which has highly redundant information and is difficult to summarize. The GO enrichment results can be reduced by clustering GO terms into groups where in the same group the GO terms have similar information. The similarity between GO terms is called <strong>the semantic similarity</strong> and can be calculated by many software such as <a href="https://bioconductor.org/packages/release/bioc/html/GOSemSim.html">the <strong>GOSemSim</strong> package</a>. Figure 1 is an example of the semantic similarity matrix from 500 randomly generated GO terms.</p>
<div class="figure" style="text-align: center">
<img src="simplifyGO_files/figure-html/unnamed-chunk-2-1.png" alt="Figure 1. A heatmap of the semantic similarity matrix from 500 random GO terms." width="384"><p class="caption">
Figure 1. A heatmap of the semantic similarity matrix from 500 random GO terms.
</p>
</div>
<p>The GO similarity heatmap has a very special pattern that there are blocks located in the diagonal where GO terms in the same block share similar functions. This is due to the structure of the GO relationship which is in a form of <a href="http://geneontology.org/docs/ontology-documentation/#the-go-graph">the Directed Acyclic Graph (DAG)</a>. Terms in a same branch of the graph tend to be more similar where more to the leaves of the graph, the similarity is stronger. In the similarity heatmap, large blocks correspond to the sets of GO terms in large branches or more consentrated to the root of the graph, while small blocks contain GO terms in smaller branches or more to the leaves of the graph.</p>
<p>Classifying GO terms into groups basically is a task of clustering the GO simialrity matrix. To solve this problem, there are two types of approaches: 1. the clustering methods that directly apply to a matrix, <em>e.g.</em>, <em>k</em>-means clustering, and 2. the methods that treat the similarity matrix as an adjacency matrix and convert the matrix to a weighted graph/network, then graph community/module detection methods are applied to partition the graph.</p>
<p>In the GO graph, there are large branches and small branches, also the branches may have differnet depth in the graph, which causes two major problems for clustering GO terms. First, the sizes of the GO clusters vary a lot, which means, there are very large clusters, and at the same time, there are also many tiny clusters. Large clusters tend to have relatively lower mean similarities across terms while small clusters have relatively higher mean similarity values. Methods such as <em>k</em>-means cannot preserve the large cluster but further split it into smaller clusters, which might produce redundancy information among these smaller clusters, and on the other hand, they are not able to separate tiny clusters. 2. Large GO clusters contain many terms and locate more to the root of the GO tree, which makes it possible that some terms in cluster A also share similarities to terms in cluster B. In the other words, large clusters are less mutually exclusive than small cluster. Some graph community detection methods merge cluster A and B into a larger cluster. These two problems can be summarized as 1. large clusters are split into small clusters and 2. large clusters are merged into larger cluster. Thus, we need to find a effective method to balance these two scenarios. This is a balance between the generality and specificity of GO clusters.</p>
<p>Here we proposed a new clustering method called “<strong>binary cut</strong>” to spit GO terms into groups. The idea behind is very simple and staightforward which is to identify “blocks” in the similarity heatmap. As shown in Figure 2, the both two heatmaps are similarity matrices for two subsets of GO terms.</p>
<div class="figure" style="text-align: center">
<img src="simplifyGO_files/figure-html/unnamed-chunk-3-1.png" alt="Figure 2. Two similarity matrices that correspond to two subsets of GO terms." width="50%"><p class="caption">
Figure 2. Two similarity matrices that correspond to two subsets of GO terms.
</p>
</div>
<p>Let’s denote the two matrices as <span class="math inline">\(M_a\)</span> (the left matrix) and <span class="math inline">\(M_b\)</span> (the right matrix). Intuitively, terms in <span class="math inline">\(M_a\)</span> all have high pairwise similarity and thus should be treated as one single cluster and should not be split any more, while terms in <span class="math inline">\(M_b\)</span> still show two-block pattern and should be further split into two more groups. To measure whether a certain subset of GO terms need to be split, we calculate a score denoted as <span class="math inline">\(s\)</span> as follows:</p>
<p>For a similarity atrix which corresponds to a subset of GO terms, <em>e.g.</em>, <span class="math inline">\(M_a\)</span> or <span class="math inline">\(M_b\)</span>, <em>k</em>-means clustering with two groups is applied on rows and columns and partitions the matrix into four parts, as illustrated in Figure 2. Denote the score for the four partitions as <span class="math inline">\(s_{11}\)</span>, <span class="math inline">\(s_{12}\)</span>, <span class="math inline">\(s_{21}\)</span> and <span class="math inline">\(s_{22}\)</span>, where <em>e.g.</em>, <span class="math inline">\(s_{11}\)</span> is the median value of the corresponding sub-matrix, the score <span class="math inline">\(s\)</span> is calculated as:</p>
<p><span class="math display">\[s = \frac{s_{11} + s_{22}}{s_{11} + s_{12} + s_{21} + s_{22}}\]</span></p>
<p>Naturally, if <span class="math inline">\(s\)</span> is close to 0.5 (<em>e.g.</em>, the left heatmap), all terms are highly similar and they should not be split any more, while if <span class="math inline">\(s\)</span> is close to 1, it means the GO terms can still be split into more groups.</p>
<p>The “binary cut” algorithm is composed of two phases:</p>
<p><strong>Phase 1: apply divisive clustering (the top-down approach) and generate a dendrogram.</strong></p>
<ol style="list-style-type: decimal">
<li>for a similarity matrix from a set of GO terms, apply <em>k</em>-means clustering with two groups, calculate the score <span class="math inline">\(s\)</span> and store it on the current node of the dendrogram.</li>
<li>for the two subsets of GO terms partitioned in step 1, apply step 1 to the two sub-matrices respectively.</li>
</ol>
<p>The clustering in step 1 and 2 are executed recursively untile the number of GO terms in a group reaches 1 which is treated as the leaves of the dendrogram.</p>
<p><strong>Phase 2: cut the dendrogram and generate partitions.</strong> Since every node in the dendrogram has a score <span class="math inline">\(s\)</span> attached, we simply test <span class="math inline">\(s\)</span> to a cutoff (0.85 as the default). If <span class="math inline">\(s\)</span> is larger than the cutoff, the two branches from the node is split, or else all the terms under the node are taken as one single cluster.</p>
<p>Nodes with large number of terms tend to have relatively smaller <span class="math inline">\(s\)</span>, thus, it is possible at a certain node, <span class="math inline">\(s\)</span> does not exceed the cutoff (very close to it), while its child nodes have <span class="math inline">\(s\)</span> larger than the cutoff. In this case, we don’t want to close the node so early and we still split this node into two subgroups so that its child nodes can be split further more. To overcome this, the rule in phase 2 are modified as: <strong>If a node does not exceed the cutoff, but if at least one of its child nodes exceed the cutoff, the node is still split.</strong></p>
<p>Examples of the step-wise clustering are illustrated in Figure 3 (the first 4 iterations):</p>
<div class="figure" style="text-align: center">
<img src="simplifyGO_files/figure-html/unnamed-chunk-4-1.png" alt="Figure 3. Process of binary clustering the similarity matrix. In the plot only the first 4 iterations are shown." width="1920"><p class="caption">
Figure 3. Process of binary clustering the similarity matrix. In the plot only the first 4 iterations are shown.
</p>
</div>
<p>Figure 4 illustrates the complete dendrogram and the partitions in the heatmap. In the dendrogram, for each node, the score corresponds to the color of the edge connected to the top of the node. The edges in grey connect the leaves of the dendrogram. The nodes marked with cross lines are the nodes that need to be split under the default cutoff (0.85).</p>
<div class="figure" style="text-align: center">
<img src="simplifyGO_files/figure-html/unnamed-chunk-5-1.png" alt="Figure 4. Partition GO terms by splitting the dendrogram." width="576"><p class="caption">
Figure 4. Partition GO terms by splitting the dendrogram.
</p>
</div>
<p>In Figure 4 we can see there are a lot of tiny clusters that they can actually be put into a separated group. Figure 5 is an improved visualization where clusters with size less than 5 are put into a separated group marked by a green line and moved to the bottom right of the heatmap. This makes the plot looks more clean.</p>
<div class="figure" style="text-align: center">
<img src="simplifyGO_files/figure-html/unnamed-chunk-6-1.png" alt="Figure 5. An improved visualization on the clustering of GO terms." width="480"><p class="caption">
Figure 5. An improved visualization on the clustering of GO terms.
</p>
</div>
<p>Once the GO terms are clustered into groups, the functions of the terms in each group can be summarized by word clouds of keywords, illustrated in Figure 6.</p>
<div class="figure" style="text-align: center">
<img src="simplifyGO_files/figure-html/unnamed-chunk-7-1.png" alt="Figure 6. A clustering of GO terms with word clouds as the annotation." width="768"><p class="caption">
Figure 6. A clustering of GO terms with word clouds as the annotation.
</p>
</div>
</div>
<div id="usage" class="section level2">
<h2 class="hasAnchor">
<a href="#usage" class="anchor"></a>Usage</h2>
<p><strong>simplifyGO</strong> starts with the GO similarity matrix. Users can use their own similarity matrices or use the <code><a href="../reference/GO_similarity.html">GO_similarity()</a></code> function to calculate one. The <code><a href="../reference/GO_similarity.html">GO_similarity()</a></code> function is simply a wrapper on <code><a href="https://rdrr.io/pkg/GOSemSim/man/mgoSim.html">GOSemSim::mgoSim</a></code>. The function accepts a vector of GO IDs. Note the GO should only belong to one same ontology (<em>i.e.</em>, <code>BP</code>, <code>CC</code> or <code>MF</code>).</p>
<p>In the following example, we sample 500 random GO IDs from GO Biological Process (BP) ontology.</p>
<div class="sourceCode" id="cb1"><html><body><pre class="r"><span class="fu"><a href="https://rdrr.io/r/base/library.html">library</a></span>(<span class="no">simplifyEnrichment</span>)
<span class="fu"><a href="https://rdrr.io/r/base/Random.html">set.seed</a></span>(<span class="fl">888</span>)
<span class="no">go_id</span> <span class="kw">=</span> <span class="fu"><a href="../reference/random_GO.html">random_GO</a></span>(<span class="fl">500</span>)
<span class="no">mat</span> <span class="kw">=</span> <span class="fu"><a href="../reference/GO_similarity.html">GO_similarity</a></span>(<span class="no">go_id</span>)</pre></body></html></div>
<p>By default, <code><a href="../reference/GO_similarity.html">GO_similarity()</a></code> uses <code>Rel</code> method in <code><a href="https://rdrr.io/pkg/GOSemSim/man/mgoSim.html">GOSemSim::mgoSim</a></code>. Other methods to calculate GO similarities can be set by <code>measure</code> argument, <em>e.g.</em>:</p>
<div class="sourceCode" id="cb2"><html><body><pre class="r"><span class="fu"><a href="../reference/GO_similarity.html">GO_similarity</a></span>(<span class="no">go_id</span>, <span class="kw">measure</span> <span class="kw">=</span> <span class="st">"Wang"</span>)</pre></body></html></div>
<p>With the similarity matrix <code>mat</code>, users can directly apply <code><a href="../reference/simplifyGO.html">simplifyGO()</a></code> function to perform the clustering as well as visualizing the results. The plot is the same as Figure 6, thus here we won’t generate it again in the vignette.</p>
<div class="sourceCode" id="cb3"><html><body><pre class="r"><span class="no">df</span> <span class="kw">=</span> <span class="fu"><a href="../reference/simplifyGO.html">simplifyGO</a></span>(<span class="no">mat</span>)</pre></body></html></div>
<p>In <code><a href="../reference/simplifyGO.html">simplifyGO()</a></code>, besides the default clustering method <code>binary_cut</code>, users can also use other clustering methods. The supported methods are:</p>
<ul>
<li>
<code>binary_cut</code>: This is the default clustering method and it uses <code><a href="../reference/binary_cut.html">binary_cut()</a></code>.</li>
<li>
<code>kmeans</code>: It uses <em>k</em>-means clustering. The number of clusters are tried with <code>2:min(round(nrow(mat)/5), 100)</code>. The best number of <em>k</em> for <em>k</em>-means clustering is identified according to the “elbow” or “knee” method on the distribution of within-cluster sum of squares at each <em>k</em>.</li>
<li>
<code>dynamicTreeCut</code> It uses <code><a href="https://rdrr.io/pkg/dynamicTreeCut/man/cutreeDynamic.html">dynamicTreeCut::cutreeDynamic()</a></code>.</li>
<li>
<code>mclust</code>: It uses <code><a href="https://mclust-org.github.io/mclust/reference/Mclust.html">mclust::Mclust()</a></code>. The value of <code>G</code> in <code><a href="https://mclust-org.github.io/mclust/reference/Mclust.html">mclust::Mclust()</a></code> is set to <code>1:min(round(nrow(mat)/5), 100)</code>. Note this method is very time-consuming.</li>
<li>
<code>apcluster</code>: It uses <code><a href="https://rdrr.io/pkg/apcluster/man/apcluster-methods.html">apcluster::apcluster()</a></code>.</li>
<li>
<code>fast_greedy</code>: It treats the similarity matrix as an adjacency matrix and converts it to a graph where the similarity values are the weight of the edges in the graph. Then the clustering on the similarity matrix is converted to looking for communities in the graph. This method applies <code><a href="https://rdrr.io/pkg/igraph/man/cluster_fast_greedy.html">igraph::cluster_fast_greedy()</a></code> to detect communities in the graph.</li>
<li>
<code>leading_eigen</code>: It is a graph community detection method. It uses <code><a href="https://rdrr.io/pkg/igraph/man/cluster_leading_eigen.html">igraph::cluster_leading_eigen()</a></code>.</li>
<li>
<code>louvain</code>: It is a graph community detection method. It uses <code><a href="https://rdrr.io/pkg/igraph/man/cluster_louvain.html">igraph::cluster_louvain()</a></code>.</li>
<li>
<code>walktrap</code>: It is a graph community detection method. It uses <code><a href="https://rdrr.io/pkg/igraph/man/cluster_walktrap.html">igraph::cluster_walktrap()</a></code>.</li>
</ul>
<p><strong>Please note, all other methods are mainly for comparing to the <code>binary_cut</code> method. They are not recommended to use.</strong></p>
<p>On the right side of the heatmap there are the word cloud annotations which summarize the functions with keywords in every GO cluster. Following parameters control the generation and graphic parameters of the word clouds:</p>
<ul>
<li>
<code>draw_word_cloud</code>: Whether to draw the word clouds.</li>
<li>
<code>min_term</code>: Minimal number of GO terms in a cluster. All the clusters with size less than <code>min_term</code> are all merged into one single cluster in the heatmap. Default is 5.</li>
<li>
<code>order_by_size</code>: Whether to reorder GO clusters by their sizes. The cluster that is merged from small clusters (size &lt; <code>min_term</code>) is always put to the bottom right of the heatmap.</li>
<li>
<code>exclude_words</code>: Words that are excluded in the word cloud. <em>E.g.</em>, in previous example, the word “regulation” and “process” can be excluded because they have very high frequency in the word clouds but are not very helpful for interpreting the results.</li>
<li>
<code>max_words</code>: Maximal number of words visualized in the word cloud, <em>i.e.</em>, the top words with the highest frequency.</li>
<li>
<code>word_cloud_grob_param</code>: This controls the graphic parameters for the word clouds. The value should be a list and is passed to <code><a href="../reference/word_cloud_grob.html">word_cloud_grob()</a></code> function. There are following graphic parameters:
<ul>
<li>
<code>line_space</code>: Space between lines. The value can be a <code><a href="https://rdrr.io/r/grid/unit.html">grid::unit</a></code> object or a numeric scalar which is measured in mm.</li>
<li>
<code>word_space</code>: Space between words. The value can be a <code><a href="https://rdrr.io/r/grid/unit.html">grid::unit</a></code> object or a numeric scalar which is measured in mm.</li>
<li>
<code>max_width</code>: The maximal width of the viewport to put the word cloud. The value can be a <code><a href="https://rdrr.io/r/grid/unit.html">grid::unit</a></code> object or a numeric scalar which is measured in mm. Note this might be larger than the final width of the returned grob object.</li>
<li>
<code>col</code>: Colors for the words. The value should be a self-defined function that takes the number of words and font size as the two arguments. The function should return a color vector. By default it uses random colors.</li>
</ul>
</li>
<li>
<code>fontsize_range</code>: The range of the font size. The value should be a numeric vector with length two. The minimal font size is mapped to word frequency value of 1 and the maximal font size is mapped to the maximal word frequency. The font size interlopation is linear.</li>
</ul>
<p>Note there is no word cloud for the cluster that is merged from small clusters (size &lt; <code>min_term</code>).</p>
<p>The returned variable <code>df</code> is a data frame with GO IDs, GO term names and the cluster labels:</p>
<div class="sourceCode" id="cb4"><html><body><pre class="r"><span class="fu"><a href="https://rdrr.io/r/utils/head.html">head</a></span>(<span class="no">df</span>)</pre></body></html></div>
<pre><code>##           id                                            term cluster
## 1 GO:0003283                       atrial septum development       1
## 2 GO:0060032                            notochord regression       1
## 3 GO:0031334 positive regulation of protein complex assembly       2
## 4 GO:0097476              spinal cord motor neuron migration       1
## 5 GO:1901222           regulation of NIK/NF-kappaB signaling       3
## 6 GO:0018216                   peptidyl-arginine methylation       4</code></pre>
<p>The size of GO clusters can be retrieved by:</p>
<div class="sourceCode" id="cb6"><html><body><pre class="r"><span class="fu"><a href="https://rdrr.io/r/base/sort.html">sort</a></span>(<span class="fu"><a href="https://rdrr.io/r/base/table.html">table</a></span>(<span class="no">df</span>$<span class="no">cluster</span>))</pre></body></html></div>
<pre><code>## 
##   6   7  11  12  14  15  17  19  20  22  23  25  26  27  28  29  30  31  32  33  34  35  36  37  38 
##   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1 
##  21  18   8   9  16  10  13  24   2   5   3   4   1 
##   2   3   5   6   6   7   7   7  28  56  82 119 147</code></pre>
<p>Or split the data by the cluster labels:</p>
<div class="sourceCode" id="cb8"><html><body><pre class="r"><span class="fu"><a href="https://rdrr.io/r/base/split.html">split</a></span>(<span class="no">df</span>, <span class="no">df</span>$<span class="no">cluster</span>)</pre></body></html></div>
<p><code>plot</code> argument can be set to <code>FALSE</code> in <code><a href="../reference/simplifyGO.html">simplifyGO()</a></code>, so that no plot is generated and only the data frame is returned.</p>
<p>If the aim is only to cluster GO terms, <code><a href="../reference/binary_cut.html">binary_cut()</a></code> function can be directly applied:</p>
<div class="sourceCode" id="cb9"><html><body><pre class="r"><span class="fu"><a href="../reference/binary_cut.html">binary_cut</a></span>(<span class="no">mat</span>)</pre></body></html></div>
<pre><code>##   [1]  1  1  2  1  3  4  5  4  1  4  6  5  1  4  5  4  1  4  1  4  1  1  7  8  1  4  4  3  4  3  3
##  [32]  4  3  1  4  1  4  4  3  1  4  3  4  1  9  4  5  1  8  2  1  4  3  3  3  1  4  3  3  4  3  5
##  [63]  1  4  4  4  1  4  3  1  3 10  1  5  1 11  2  8  4  1  3 12 13  1  1  3  1  5  3 14  1  1  3
##  [94]  4  4  4  3  4  8  1  1  8  8  5  2  3  1  2  3  3  1  3 15  1  3  3  1  4  2  4  3 16  1  4
## [125]  3  2  8  4  3  8  4  4 17  5  2  2  1  1  4  1  4  5  2  1  1 18  1  1  4  1  2 19  3  1  1
## [156]  1  1  4  1  1  1  4  8  1  2  1  5  3  1  5  3  4  1  3  3  3  4  1  1 11  5  3  3 12  3  1
## [187]  5  8  3  1  3 20  4  1  4  2  1  1  1 11  1  1  4  3  3  2  1  3  4  4  1  3  4  5  5  1 21
## [218] 12  3 16  2  4  2  4  2  2  4  2  1  1  4  2  1  5  4  9  4  3  5  3  1 22  3  1  4  1  1  3
## [249]  5  3  8  1  1  1  4  1  3  3  4  3  1 23  1  1 24 25  9  4  3  5  3  1  1 22  4 26  5  3  5
## [280]  1  1  4  4  5  1  3  3  2  3 16  4  4  4 19  8  4  3  3  4 11  4  1  1  9  2  3  1  1  2  1
## [311]  1  2  4  4  1  1  4  4  4  1  3  3 27  5  3  3  3  2  1  1  1  3  1  4  2  4  4  3  3  3  1
## [342]  3  1  4  1  4  1 12  3  1  5 12  1  1  3  1  1  4  1  1  8  4  1  4  4  4  1  1  3  1  4 12
## [373]  4  1  4  4  3  3  4  1  2  5  4  5  4  4  4 28  4  4  3  4  1  3  2  3  2 29  4  3  1  2  1
## [404]  1  2  8  4  3  1  2  1  3  1  5  1  4  3  5 22  1  3 22  4  3  3 30  1  4  3  1  4  9 22 16
## [435]  4  4  9  1  1  3  5  1  4  1  5  4  1  1  1 31  1  3  3  1 12  1  1  4  4  4  5  3 32  8  4
## [466]  4  5 33  3  1  4  1  3  1  1  1  4  1  1  4  4  1  1  4  4  4  8 34 22  3  4  4  4 35 36  3
## [497]  5  3 37  5</code></pre>
</div>
<div id="benchmark" class="section level2">
<h2 class="hasAnchor">
<a href="#benchmark" class="anchor"></a>Benchmark</h2>
<p>We compare the following clustering methods to binary cut: <code>kmeans</code>, <code>dynamicTreeCut</code>, <code>mclust</code>, <code>apcluster</code>, <code>fast_greedy</code>, <code>leading_eigen</code>, <code>louvain</code> and <code>walktrap</code>. The actual R functions used to perform corresponding analysis can be found in text in previous sections in this vignette.</p>
<div id="on-random-datasets" class="section level3">
<h3 class="hasAnchor">
<a href="#on-random-datasets" class="anchor"></a>On random datasets</h3>
<p>500 random GO terms are generated from Biology Process ontology. One example of the clustering from different methods is illustrated in Figure 7. Basically we can see <code>kmeans</code>, <code>dynamicTreeCut</code>, <code>mclust</code> and <code>apcluster</code> generate too many small clusters and put tiny cluster into a same group. <code>fast_greedy</code>, <code>leading_eigen</code>, <code>louvain</code> and <code>walktrap</code> can identify both small and large clusters, however, some large clusters should still need to be split further more.</p>
<div class="figure" style="text-align: center">
<img src="GO_heatmap_random_BP.jpg" alt="Figure 7. Compare clustering from different methods. Tiny clusters (size &lt; 5) are merged into a separated cluster marked by a green line." width="650"><p class="caption">
Figure 7. Compare clustering from different methods. Tiny clusters (size &lt; 5) are merged into a separated cluster marked by a green line.
</p>
</div>
<p>We use the following metrics to benchmark the clustering methods:</p>
<ol style="list-style-type: decimal">
<li>
<strong>Different score</strong>: This is the difference between the similarity values for the terms that belong to the same clusters and in different clusters. For a similarity matrix <span class="math inline">\(M\)</span>, for term <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span> where <span class="math inline">\(i \ne j\)</span>, the similarity value <span class="math inline">\(x_{i,j}\)</span> is saved to the vector <span class="math inline">\(\mathbf{x_1}\)</span> only when term <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span> are in a same cluster. <span class="math inline">\(x_{i,j}\)</span> is saved to the vector <span class="math inline">\(\mathbf{x_2}\)</span> when term <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span> are not in the same cluster. The difference score measure the distribution difference between <span class="math inline">\(\mathbf{x_1}\)</span> and <span class="math inline">\(\mathbf{x_2}\)</span>, calculated as the Kolmogorov-Smirnov statistic between the two distributions.</li>
<li>
<strong>Number of clusters</strong>: For each clustering, there are two numbers: the number of total clusters and the number of clusters with size &gt;= 5 (only the big clusters).</li>
<li>
<strong>Block mean</strong>: The mean similarity values of the blocks in the similarity heatmap. Similar denotation as in difference score, for a similarity matrix <span class="math inline">\(M\)</span>, for term <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span> where <span class="math inline">\(i\)</span> can be the same as <span class="math inline">\(j\)</span>, the similarity value <span class="math inline">\(x_{i,j}\)</span> is saved to the vector <span class="math inline">\(\mathbf{x_1}\)</span> only when term <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span> are in a same cluster. The block mean is the mean value over <span class="math inline">\(\mathbf{x_1}\)</span>.</li>
</ol>
<p>The random GO terms were generated 100 times and the metrics are compared in Figure 8.</p>
<p>In the left plot in Figure 8, we can see binary cut has the highest difference score, which means, in the clustering by binary cut, the terms in the same clusters shows the most distinct distribution to the rest of values in the similarity matrix. <code>dynamicTreeCut</code> and <code>apcluster</code> generates huge number of clusters, as we already see in Figure 7. They just too stringent to cluster GO terms that they should have high redundant information between clusters. As a comparison, community-based methods and binary cut generates moderate number of clusters, especially, the number of “big cluster” (those with size &gt;= 5) drops dramatically compare to the total clusters, indicating these methods are able to identify tiny clusters that have very low similarity to any other terms. Binary cut generates clusters with moderate “block mean”, while <code>kmeans</code>, <code>dynamicTreeCut</code>, <code>mclust</code> and <code>apcluster</code> generate very high block mean and community detection methods generate very low block mean. This indicate binary cut keeps both generality and flexibility of GO clusters.</p>
<p>Next we look at the similarity between clustering methods. For the clustering from two methods, first the cluster labels are adjusted. Denote <span class="math inline">\(\mathbf{s_1}\)</span> is the label vector for method 1 and <span class="math inline">\(\mathbf{s_2}\)</span> is the label vector for method 2, and <span class="math inline">\(\mathbf{s_1}\)</span> is taken as the reference labels, we apply <code><a href="https://rdrr.io/pkg/clue/man/solve_LSAP.html">clue::solve_LSAP()</a></code> function generate a mapping function <span class="math inline">\(m()\)</span> between the two sets of labels to maximize <span class="math inline">\(\sum_i I(s_{1i}, m(s_{2i}))\)</span>. Denote the adjusted labels for the second method as <span class="math inline">\(s'_{2i} = map(s_{2i})\)</span>, the concordance between the two clusterings are calculated as:</p>
<p><span class="math display">\[ \frac{1}{n}\sum_i^n I(s_{1i}, s'_{2i}) \]</span></p>
<p>where <span class="math inline">\(I(x, y)\)</span> is an indicator function to be 1 if <span class="math inline">\(x = y\)</span> and 0 if <span class="math inline">\(x \ne y\)</span>.</p>
<p>Right plot in Figure 8 illustrates the heatmap for the mean concordance over 500 random runs. We see binary cut shows similar clusterings as the community detection methods.</p>
<div class="figure" style="text-align: center">
<img src="simplifyGO_files/figure-html/unnamed-chunk-16-1.png" alt="Figure 8. Compare metrics for different clustering methods, on randomly generated datasets." width="960"><p class="caption">
Figure 8. Compare metrics for different clustering methods, on randomly generated datasets.
</p>
</div>
<p>The heatmaps for the 100 runs of clustering random GO terms can be found at <a href="https://jokergoo.github.io/simplifyGO_figures/random_BP.html" class="uri">https://jokergoo.github.io/simplifyGO_figures/random_BP.html</a>.</p>
</div>
<div id="on-real-datasets" class="section level3">
<h3 class="hasAnchor">
<a href="#on-real-datasets" class="anchor"></a>On real datasets</h3>
<p>We downloaded the datasets from <a href="https://www.ebi.ac.uk/gxa/download">EBI Expression Atlas</a>. We applied <a href="https://bioconductor.org/packages/release/bioc/html/clusterProfiler.html"><strong>clusterProfiler</strong></a> to the significantly expressed genes (FDR &lt; 0.05, number of significant genes in [500, 3000]) only with the GO Biological Process ontology. We only took the datasets with number of significant GO terms in [100, 1000]. Finally there are 475 GO lists.</p>
<p>Figure 9 illustrates the results for the comparison. The conclusion is basically the same as the random GO datasets.</p>
<p>The heatmaps for all datasets can be found at <a href="https://jokergoo.github.io/simplifyGO_figures/EBI_Expression_Atlas.html" class="uri">https://jokergoo.github.io/simplifyGO_figures/EBI_Expression_Atlas.html</a>.</p>
<div class="figure" style="text-align: center">
<img src="simplifyGO_files/figure-html/unnamed-chunk-17-1.png" alt="Figure 9. Compare metrics for different clustering methods, on real-world datasets." width="960"><p class="caption">
Figure 9. Compare metrics for different clustering methods, on real-world datasets.
</p>
</div>
</div>
<div id="utility-functions-for-comparing-clustering-methods" class="section level3">
<h3 class="hasAnchor">
<a href="#utility-functions-for-comparing-clustering-methods" class="anchor"></a>Utility functions for comparing clustering methods</h3>
<p>In the <strong>simplifyEnrichment</strong> package, there are also functions that compare clustering results from different methods. Here we still use previously generated variable <code>mat</code> which is the similarity matrix from the 500 random GO terms. Simply running <code><a href="../reference/compare_methods.html">compare_methods()</a></code> performs all the supported methods (encoded in <code>simplifyEnrichment:::ALL_CLUSTERING_METHODS</code>) excluding <code>mclust</code>, since <code>mclust</code> usually takes very long time to run. The function generates a figure with three panels:</p>
<ol style="list-style-type: decimal">
<li>A heatmap of the similarity matrix with different clusterings as row annotations.</li>
<li>A heatmap of the pair-wise concordance of the clustering of every two methods.</li>
<li>Barplots of the difference scores for each method, the number of clusters (all clusters and the clusters with size &gt;= 5) and the mean similarity of the terms that are in the same clusters. The methods to calculate these metrics are introduced in the previous section.</li>
</ol>
<div class="sourceCode" id="cb11"><html><body><pre class="r"><span class="fu"><a href="../reference/compare_methods.html">compare_methods</a></span>(<span class="no">mat</span>)</pre></body></html></div>
<pre><code>## cluster 500 terms by kmeans... 19 clusters.
## cluster 500 terms by dynamicTreeCut... 60 clusters.
## cluster 500 terms by apcluster... 45 clusters.
## cluster 500 terms by fast_greedy... 26 clusters.
## cluster 500 terms by leading_eigen... 25 clusters.
## cluster 500 terms by louvain... 25 clusters.
## cluster 500 terms by walktrap... 25 clusters.
## cluster 500 terms by binary_cut... 39 clusters.</code></pre>
<div class="figure" style="text-align: center">
<img src="simplifyGO_files/figure-html/unnamed-chunk-18-1.png" alt="Figure 10. Compare different clustering methods." width="960"><p class="caption">
Figure 10. Compare different clustering methods.
</p>
</div>
<p>If <code>plot_type</code> argument is set to <code>heatmap</code>. There are heatmaps for the similarity matrix under clusterings from different methods. The last panel is a table with the number of clusters under different clusterings. <code>nrow</code> argument controls the number of rows in the layout.</p>
<div class="sourceCode" id="cb13"><html><body><pre class="r"><span class="co"># The following code may take long time to run (several minutes)</span>
<span class="fu"><a href="../reference/compare_methods.html">compare_methods</a></span>(<span class="no">mat</span>, <span class="kw">plot_type</span> <span class="kw">=</span> <span class="st">"heatmap"</span>)
<span class="fu"><a href="../reference/compare_methods.html">compare_methods</a></span>(<span class="no">mat</span>, <span class="kw">plot_type</span> <span class="kw">=</span> <span class="st">"heatmap"</span>, <span class="kw">nrow</span> <span class="kw">=</span> <span class="fl">3</span>)</pre></body></html></div>
<p>Please note, the clustering methods might have randomness, which means, different runs of <code><a href="../reference/compare_methods.html">compare_methods()</a></code> may generate different clusterings (slightly different). Thus, if users want to compare the plots between <code><a href="../reference/compare_methods.html">compare_methods(mat)</a></code> and <code><a href="../reference/compare_methods.html">compare_methods(mat, plot_type = "heatmap")</a></code>, they should set the same random seed before executing the function.</p>
<div class="sourceCode" id="cb14"><html><body><pre class="r"><span class="fu"><a href="https://rdrr.io/r/base/Random.html">set.seed</a></span>(<span class="fl">123</span>)
<span class="fu"><a href="../reference/compare_methods.html">compare_methods</a></span>(<span class="no">mat</span>)
<span class="fu"><a href="https://rdrr.io/r/base/Random.html">set.seed</a></span>(<span class="fl">123</span>)
<span class="fu"><a href="../reference/compare_methods.html">compare_methods</a></span>(<span class="no">mat</span>, <span class="kw">plot_type</span> <span class="kw">=</span> <span class="st">"heatmap"</span>)</pre></body></html></div>
<p><code><a href="../reference/compare_methods.html">compare_methods()</a></code> is simply a wrapper on <code><a href="../reference/compare_methods_make_clusters.html">compare_methods_make_clusters()</a></code> and <code><a href="../reference/compare_methods_make_plot.html">compare_methods_make_plot()</a></code> functions where the former function performs clustering with different methods and the latter visualizes the results. To compare different plots, users can also use the following code without specifying the random seed.</p>
<div class="sourceCode" id="cb15"><html><body><pre class="r"><span class="no">clt</span> <span class="kw">=</span> <span class="fu"><a href="../reference/compare_methods_make_clusters.html">compare_methods_make_clusters</a></span>(<span class="no">mat</span>) <span class="co"># just a list of cluster labels</span>
<span class="fu"><a href="../reference/compare_methods_make_plot.html">compare_methods_make_plot</a></span>(<span class="no">mat</span>, <span class="no">clt</span>)
<span class="fu"><a href="../reference/compare_methods_make_plot.html">compare_methods_make_plot</a></span>(<span class="no">mat</span>, <span class="no">clt</span>, <span class="kw">plot_type</span> <span class="kw">=</span> <span class="st">"heatmap"</span>)</pre></body></html></div>
</div>
</div>
<div id="session-info" class="section level2">
<h2 class="hasAnchor">
<a href="#session-info" class="anchor"></a>Session Info</h2>
<div class="sourceCode" id="cb16"><html><body><pre class="r"><span class="fu"><a href="https://rdrr.io/r/utils/sessionInfo.html">sessionInfo</a></span>()</pre></body></html></div>
<pre><code>## R version 4.0.0 (2020-04-24)
## Platform: x86_64-apple-darwin17.0 (64-bit)
## Running under: macOS Catalina 10.15.4
## 
## Matrix products: default
## BLAS:   /Library/Frameworks/R.framework/Versions/4.0/Resources/lib/libRblas.dylib
## LAPACK: /Library/Frameworks/R.framework/Versions/4.0/Resources/lib/libRlapack.dylib
## 
## locale:
## [1] en_GB.UTF-8/en_GB.UTF-8/en_GB.UTF-8/C/en_GB.UTF-8/en_GB.UTF-8
## 
## attached base packages:
##  [1] parallel  stats4    grid      stats     graphics  grDevices utils     datasets  methods  
## [10] base     
## 
## other attached packages:
##  [1] ggplot2_3.3.0             cowplot_1.0.0             org.Hs.eg.db_3.10.0      
##  [4] AnnotationDbi_1.50.0      IRanges_2.22.1            S4Vectors_0.26.0         
##  [7] Biobase_2.48.0            BiocGenerics_0.34.0       ComplexHeatmap_2.5.1     
## [10] circlize_0.4.9            simplifyEnrichment_0.99.0 knitr_1.28               
## 
## loaded via a namespace (and not attached):
##  [1] dynamicTreeCut_1.63-1 bit64_0.9-7           assertthat_0.2.1      highr_0.8            
##  [5] blob_1.2.1            yaml_2.2.1            slam_0.1-47           lattice_0.20-41      
##  [9] pillar_1.4.3          RSQLite_2.2.0         backports_1.1.6       glue_1.4.0           
## [13] digest_0.6.25         RColorBrewer_1.1-2    gridtext_0.1.1        colorspace_1.4-1     
## [17] htmltools_0.4.0       Matrix_1.2-18         tm_0.7-7              pkgconfig_2.0.3      
## [21] GetoptLong_0.1.8      purrr_0.3.4           GO.db_3.10.0          scales_1.1.0         
## [25] jpeg_0.1-8.1          tibble_3.0.1          farver_2.0.3          ellipsis_0.3.0       
## [29] withr_2.2.0           NLP_0.2-0             magrittr_1.5          crayon_1.3.4         
## [33] memoise_1.1.0         evaluate_0.14         apcluster_1.4.8       fs_1.4.1             
## [37] MASS_7.3-51.6         xml2_1.3.2            tools_4.0.0           GlobalOptions_0.1.1  
## [41] lifecycle_0.2.0       stringr_1.4.0         munsell_0.5.0         cluster_2.1.0        
## [45] compiler_4.0.0        pkgdown_1.5.1         gridGraphics_0.5-0    rlang_0.4.5          
## [49] rjson_0.2.20          igraph_1.2.5          labeling_0.3          rmarkdown_2.1        
## [53] gtable_0.3.0          DBI_1.1.0             markdown_1.1          R6_2.4.1             
## [57] dplyr_0.8.5           bit_1.1-15.2          clue_0.3-57           rprojroot_1.3-2      
## [61] shape_1.4.4           desc_1.2.0            GOSemSim_2.14.0       stringi_1.4.6        
## [65] Rcpp_1.0.4.6          vctrs_0.2.4           png_0.1-7             tidyselect_1.0.0     
## [69] xfun_0.13</code></pre>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">

        <nav id="toc" data-toggle="toc"><h2 data-toc-skip>Contents</h2>
    </nav>
</div>

</div>



      <footer><div class="copyright">
  <p>Developed by Zuguang Gu.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="https://pkgdown.r-lib.org/">pkgdown</a> 1.5.1.</p>
</div>

      </footer>
</div>

  


  </body>
</html>
